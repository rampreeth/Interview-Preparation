System Design 

	Brief overview of all concepts - https://github.com/donnemartin/system-design-primer
	
	Youtube
		For concepts: https://www.youtube.com/channel/UCRPMAqdtSgd0Ipeef7iFsKw
		Real life system designs explained - https://www.youtube.com/channel/UCZEfiXy7PmtVTezYUvc4zZw
		Interview Experiences - https://www.youtube.com/channel/UCUm1OB1gDV0Tl0Mjx5I01-A
		For some real good explanation: https://www.youtube.com/channel/UC9vLsnF6QPYuH51njmIooCQ
	

Below are basically some points I noted down, all might not make sense to you.

IMPORTANT POINTS. [ CTCI 17.20 = Cracking of the coding interview book chapter 17 problem 20)
1. Switch to brute force quickly if you can find optimum solution. DONOT get Stuck.
2. int & (int - 1) = 0 then there is only one bit which is "1".
3. String problems can be converted to array problems if needed.
4. 1<<(string.charAt(i)-'a') gives single bit on for all alphabets.
5. for all ASCII you can use int[128]. for only caps and small, use int[58]. 
6. For counting the difference try if bit manipulation is helpful ? ( example is edit distance between two strings == 1? )
7. For bit manipulation questions, if you need to convert an integer to bit array, try to run a while loop and at each time & the int to 1 to get the least significant bit, use the value to calculate the answer, shift bits to the right by one each iteration. Example - CTCI problems:5.3 
8. For bit manipulation questions, in case of power of something is to be determined, using log function is good idea
9. For permutations of string, never actually generate all the permutations unless needed. ( sorting might be a better solution ).
10. For palindrome, checking xor all the characters and the result should have at most one bit as "1".                                                  	[for(char c: input.toCharArray()){ xor = xor ^(1<<(c-'a'));  }  return Integer.bitCount(xor) <= 1; ]
11. For linked list problems if you need to calculate the length of the linked list, think twice, you can use some byproduct to figure this out.  ( fast runner and slow runner ).
12. For problem https://leetcode.com/problems/all-paths-from-source-to-target/ adding nodes to path In forward direction is better than backward direction. For any such problem think of solution in both the direction and then decide which is easier.
13. In any recursive solution, if you have to send the last recursive call node to calling function, the return statement has to be at the end of the recursive function.
14. If you know the size of the result , try to use array and not list, because list is expensive. 
15. For any solution, check if the byproduct calculation/result is needed ? if not, try to remove it. ( ex: calculate median for two sorted arrays, you don't really need to build the result array, so try to avoid that. Also to calculate median you need to build only the first half of the array)
16. If you have gone too detailed in the solution, try to rethink the logic and merge the different logics.
17. If you cant find a solution from one end , try to use the other end. Also if the problem needs to find a width, if starting from a min width does not work, try starting from a max width. example: https://leetcode.com/problems/container-with-most-water/
18. If the intuitive logic is too hard to find, thats a right candidate for dynamic programming. example: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/.
19. Always think of null cases while solving linked list and tree problems. you can assume each variable as Node a = x | null while try to derive a solution.
20. If in the first iteration if you cant find the right answer, use it and see if you can update the right answer in the later iterations, example: https://leetcode.com/problems/daily-temperatures/ solution #4.
21. At each point if you have to remember all the sum seen from the previous steps the best data structure is HashMap. Store each sum and it frequency in the HashMap.  https://leetcode.com/problems/path-sum-iii/ solution #3. 
22. For a problem that input is a matrix, do not jump straight into finding a solution with DFS. Think which is better BFS or bfs! ( usually implemented with a queue if needed ). Example: https://leetcode.com/problems/rotting-oranges/
23. If any of the result/ intermediate result can be achieved by applying a know algorithm, then the use it and try to deduce the actual result from the working of the algorithm. Example: https://leetcode.com/problems/pancake-sorting/solution/ this problem needs us to sort the array, hence apply all known sorting algorithm and see which can be used to build the actual result expected.
24. For recursion problems involving a matrix, Ex: CTCI problems:8.2 Robot in a Grid. To eliminate duplicate work always mark a cell as visited like grid[i][j] = 2. ( To mark as seen you can also track those cells in a hashSet incase its a boolean matrix).
25. Often dynamic problems can be solved using recursion also. Try to determine the approach based on the time complexity first then space complexity.
26. if the problem is simple, write the solution but concentrate extra on the fine details and address them. CTCI 16.2
27. Use enum where ever possible instead of string or character. CTCI - 16.26 
28. Always try to think for general solution and try to modularise as much as possible. CTCI - 16.26
29. Do not hard code the input values, instead use as arguments and make it general.
30. Ask if the method will be called often, if it's called often derive a solution that does pre-processing, so the each method call can be server in O(1) or least time possible.
31. When precomputing results for the next input, consider the runtime of precomputing, if the runtime is large compared to the runtime to find the result for the next input then don't precompute. Ex CTCI 17.11. [If you precompute the distance for every pair of word then the runtime is N2, but the sol is N for precompute and M for next input, which is better ]. Think about the trade offs.
32. If group of number have to be sorted at every insertion of a new value consider a heap. CTCI 17.20
33. If you are jumbled up with number and cant get the ordering right for your result, using sorting - 3Sum
34. If you have to calculate two opposite values, use only one variable and derive the other. Example
35. You can use bit manipulation (shift operators) instead of an array which is used just to keep track of 1 or 0. Example.
